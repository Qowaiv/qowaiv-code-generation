using System.Xml.Linq;

namespace Qowaiv.OpenApi;

public static class CSharpWriter
{
    public static readonly Encoding Encoding = new UTF8Encoding(true);

    /// <summary>The used new line (\r\n).</summary>
    public static readonly string NewLine = "\r\n";

    public static TextWriter Add(this TextWriter writer, Code code, WriterSettings settings)
        => code switch
        {
            Enumeration x => writer.Add(x, settings),
            Model x => writer.Add(x, settings),
            _ => throw new NotSupportedException($"The type '{code?.GetType()}' is not supported."),
        };

    /// <summary>Writes a model.</summary>
    public static TextWriter Add(this TextWriter writer, Enumeration enumeration, WriterSettings settings)
    {
        writer.Line($"public enum {enumeration.Type.Name}");

        using (writer.CodeBlock())
        {
            foreach (var value in enumeration.Values)
            {
                writer.Line();
                writer.Add(value);
            }
        }
        return writer;
    }

    /// <summary>Writes a model.</summary>
    private static TextWriter Add(this TextWriter writer, EnumValue value)
        => writer
        .Indent().Line(@$"[EnumMember(Value = ""{value.Value}"")]")
        .Indent().Line($"{value.Name},");
        
    /// <summary>Writes a model.</summary>
    public static TextWriter Add(this TextWriter writer, Model model, WriterSettings settings)
    {
        if (settings.ModelType == ModelType.Record)
        {
            writer.Line($"public partial record {model.Type.Name}");
        }
        else
        {
            writer.Line($"public partial class {model.Type.Name}");
        }

        using (writer.CodeBlock())
        {
            if (settings.PropertyAccess == PropertyAccess.GetOnly)
            {
                writer.Indent().Line($"public {model.Type.Name}(");

                foreach (var prop in model.Properties)
                {
                    if (prop == model.Properties.LastOrDefault())
                    {
                        writer.Indent(2).Add(prop.Type, settings).Line($" {prop.Name})");
                    }
                    else
                    {
                        writer.Indent(2).Add(prop.Type, settings).Line($" {prop.Name},");
                    }
                }
                using (writer.CodeBlock(1))
                {
                    foreach (var prop in model.Properties)
                    {
                        writer.Indent(2).Line($"this.{prop.Name} = {prop.Name};");
                    }
                }
            }

            foreach (var prop in model.Properties)
            {
                writer.Line();
                writer.Add(prop, settings);
            }
        }
        return writer;
    }

    private static TextWriter Add(this TextWriter writer, Property prop, WriterSettings settings)
    {
        if (!string.IsNullOrWhiteSpace(prop.Info?.Description))
        {
            writer.Indent().Line($"/// <summary>{new XText(prop.Info.Description)}</summary>");
        }
        writer.Indent().Line($"/// <remarks><{prop.Info}/remarks>");
        if (settings.SerializerType == SerializerType.Newtonsoft)
        {
            writer.Indent().Line($@"[JsonProperty(""{prop.JsonName}"")]");
        }
        else if (settings.SerializerType == SerializerType.System_Text_Json)
        {
            writer.Indent().Line($@"[JsonPropertyName(""{prop.JsonName}"")]");
        }

        writer.Indent()
            .Add("public ")
            .Add(prop.Type, settings)
            .Add($@" {prop.Name} ");
        return settings.PropertyAccess switch
        {
            PropertyAccess.PublicSet => writer.Line("{ get; set; }"),
            PropertyAccess.InternalSet => writer.Line("{ get; internal set; }"),
            PropertyAccess.GetOnly => writer.Line("{ get; }"),
            _ => writer.Line("{ get; init; }"),
        };
    }

    /// <summary>Marks a file as generated code.</summary>
    public static TextWriter AddIsGeneratedCodeHeader(this TextWriter writer)
        => writer
        .Line("// ------------------------------------------------------------------------------")
        .Line("// <auto-generated>")
        .Line("//     This code was generated by a tool.")
        .Line("//")
        .Line("//     Changes to this file may cause incorrect behavior and will be lost if")
        .Line("//     the code is regenerated.")
        .Line("// </auto-generated>")
        .Line("// ------------------------------------------------------------------------------");

    /// <summary>Adds a namespace decaration to the line.</summary>
    public static TextWriter Line(this TextWriter writer, Namespace @namespace)
        => writer.Line($"namespace {@namespace};");

    /// <summary>Indents the current line (4 spaces per depth).</summary>
    public static TextWriter Indent(this TextWriter writer, int depth = 1)
        => writer.Add(new string(' ', depth * 4));

    /// <summary>Adds the text to the current line.</summary>
    public static TextWriter Add(this TextWriter writer, string? text)
    {
        writer.Write(text);
        return writer;
    }

    public static TextWriter Add(this TextWriter writer, DotNetType type, WriterSettings settings)
    {
        if(settings.Globals.Contains(type.Namespace))
        {
            writer.Write(type.Name);
        }
        else
        {
            writer.Write(type);
        }
        return writer;
    }

    /// <summary>Finishes the current line with the (optional) text.</summary>
    public static TextWriter Line(this TextWriter writer, string? text = null)
        => writer.Add(text).Add(NewLine);

    /// <summary>Writes a code block (`{ ... }`).</summary>
    public static IDisposable CodeBlock(this TextWriter writer, int indent = 0)
    {
        writer.Indent(indent).Line("{");
        return new ScopedCodeBlock(writer, indent);
    }

    private sealed record ScopedCodeBlock(TextWriter Writer, int Indentation) : IDisposable
    {
        public void Dispose()
        {
            Writer.Indent(Indentation).Line("}");
        }
    }
}
